var documenterSearchIndex = {"docs":
[{"location":"guide/#guide","page":"Defining a New Profile","title":"Defining a New Profile","text":"","category":"section"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"If your profile describes a 3D density distribution, create a new file under the src/densities directory. If only 2D quantities will be defined, create a new file under src/surface_densities instead. Let's say I want to define a special type for the singular isothermal sphere, rather than SIS that creates a GeneralIsothermal instance. I could create src/sis.jl and add include(\"sis.jl\") to src/densities.jl to make sure the file is loaded. Then, in src/sis.jl I could define a singular isothermal sphere as","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"\"\"\"\n    SingularIsothermalSphere(ρ0::Real, rs::Real)\n\nSingular isothermal sphere profile. Fields are `ρ0,rs`. \n\"\"\"\nstruct SingularIsothermalSphere{T<:Real} <: AbstractDensity{T}\n    ρ0::T\n    rs::T\nend\nnothing # hide","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"You should add some info about the profile to the docstring. If you are creating a 2D surface density distribution, you should subtype AbstractSurfaceDensity. You should then define additional constructors for your type. To allow the call signature we listed in the docstring above, define","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"SingularIsothermalSphere(ρ0::Real, rs::Real) = SingularIsothermalSphere(promote(ρ0, rs)...)\nnothing # hide","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"such that we can do","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"SingularIsothermalSphere(1.0, 1)","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"It is also common to define constructors that will take the total mass and scale radius as inputs and compute the characteristic density; in this example,ρ0. See the implementation of GeneralIsothermal for an example of how to do this.","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"Now you should define as many methods from the Defined Methods section as you need, starting with methods to retrieve the parameters,","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"params(d::SingularIsothermalSphere) = (d.ρ0, d.rs)\nscale_radius(d::SingularIsothermalSphere) = d.rs\nnothing # hide","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"and then evaluation methods like","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"function ρ(d::SingularIsothermalSphere, r::Real)\n    ρ0, rs = params(d)\n    return ρ0 * (r/rs)^-2\nend\nnothing # hide","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"We avoid accessing the fields of the types directly and use params and scale_radius instead so that internal fields of the types can be refactored later if necessary without having to redefine all the accompanying methods.","category":"page"},{"location":"guide/","page":"Defining a New Profile","title":"Defining a New Profile","text":"When you are done writing your methods, you should define methods for your type that allow for Unitful quantities in the src/units.jl file. You should be able to follow the examples there with little problem. You should write tests under GalaxyProfiles.jl/test to validate the behavior of your type and methods. It is recommended that you make a new file, e.g. test/mytype_tests.jl, then add include(\"mytype_tests.jl\") to the test/runtests.jl file. You should then edit src/GalaxyProfiles.jl to export your new type, in this example SingularIsothermalSphere. ","category":"page"},{"location":"units/#units","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"","category":"section"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"GalaxyProfiles.jl provides integration with Unitful.jl and UnitfulAstro.jl through Requires.jl. When both Unitful and UnitfulAstro are imported, GalaxyProfiles.jl/src/units.jl will be included, which will overload many of the default methods and constructors to work with Unitful quantities.","category":"page"},{"location":"units/#Type-Constructors","page":"Integration with Unitful.jl","title":"Type Constructors","text":"","category":"section"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"Constructors for our defined types will accept Unitful quantities with correct dimensionality. So as to not explicitly depend on Unitful and UnitfulAstro, units are never stored in types. Instead, they are converted to default units and stored in the types as Reals.","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"import Unitful as u\nimport UnitfulAstro as ua\nusing GalaxyProfiles\n\n@info \"Correct dimensions, converted and stored internally as Float64.\" # hide\nd = GeneralIsothermal(1.0 * ua.Msun / ua.kpc^3, 1.0 * ua.kpc, 2.5)\n\n@info \"Incorrect dimensions on first argument, will error.\" # hide\nd = GeneralIsothermal(1.0 * ua.Msun / ua.kpc^2, 1.0 * ua.kpc, 2.5)","category":"page"},{"location":"units/#defaultunits","page":"Integration with Unitful.jl","title":"Default Units","text":"","category":"section"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"The default units used by type constructors and methods are defined in the submodule GalaxyProfiles.defaultunits (found at the top of src/units.jl) and are generally named after the quantity that they represent. These include","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"mass: UnitfulAstro.Msun\n∇mass: UnitfulAstro.Msun / UnitfulAstro.kpc\ndensity: UnitfulAstro.Msun / UnitfulAstro.kpc^3\nsurfacedensity: UnitfulAstro.Msun / UnitfulAstro.kpc^2\nlength: UnitfulAstro.kpc\nvelocity: Unitful.km / Unitful.s\ntime: Unitful.yr\nΦunit: Unitful.km^2 / Unitful.s^2\n∇Φunit: Unitful.km^2 / Unitful.s^2 / UnitfulAstro.kpc\n∇∇Φunit: Unitful.km^2 / Unitful.s^2 / UnitfulAstro.kpc^2","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"Accompanying dimensions for proper dispatch are also defined in src/units.jl, including SurfaceDensity, ∇ρdimension, Φdimension, ∇∇Φdimension, ∇mdimension. These function like so:","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"@info \"Get Unitful package extension, if on version of Julia that supports it\" # hide\nif isdefined(Base, :get_extension)\n    ext = Base.get_extension(GalaxyProfiles, :GalaxyProfilesUnitfulExt)\nelse\n    ext = GalaxyProfiles.GalaxyProfilesUnitfulExt\nend\n1 * ua.Msun / ua.pc^2 isa ext.SurfaceDensity\nua.Msun / ua.pc^2 isa ext.SurfaceDensityUnits","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"See also the documentation for Unitful.@derived_dimension.","category":"page"},{"location":"units/#Methods","page":"Integration with Unitful.jl","title":"Methods","text":"","category":"section"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"Methods defined on Real inputs are not overloaded to return Unitful quantities. This is to ensure identical behaviors of these methods regardless of whether Unitful integration is active or not.","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"ρ(GeneralIsothermal(1.0 * ua.Msun / ua.kpc^3, 1.0 * ua.kpc, 2.5), 1.0)","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"It is therefore safest when constructing types with Unitful inputs to also call methods with Unitful inputs. Otherwise, you can accidentally end up mixing units in ways that are hard to reason about. See the section on units warning.","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"Methods that only take a GalaxyProfiles.AbstractMassProfile instance as input generally have one additional method allowing for a conversion of that quantity. For example,","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"d = ExponentialDisk(1 * ua.Msun / ua.pc^2, 100 * ua.pc)\nMtot(d) # default method\nMtot(ua.Msun, d)\nMtot(u.kg, d)","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"Methods that take a GalaxyProfiles.AbstractMassProfile and a Real will have three additional methods allowing for Unitful integrations. For example,","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"d = GeneralIsothermal(1.0 * ua.Msun / ua.kpc^3, 1.0 * ua.kpc, 2.5)\nρ(d, 1.0) # default method\nρ(ua.Msun/ua.pc^3, d, 1.0) # for real argument and a unit conversion of result\nρ(d, 1.0*ua.kpc) # for a Unitful argument\nρ(ua.Msun/ua.pc^3, d, 1.0*ua.kpc) # for Unitful argument and result conversion","category":"page"},{"location":"units/#unitswarning","page":"Integration with Unitful.jl","title":"Units Warning","text":"","category":"section"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"For example, say that I define the scale radius in parsecs when constructing a type. This will be converted and stored in the type as a plain float type with an implicit unit of kpc (see above section on default units). If I then call a method with a plain float radius argument that I expect to be in the same units as the scale radius I provided, the result will be in the wrong units. After constructing a type with Unitful quantities, all methods called on that type with plain float inputs must be in the default units that are expected. When calling methods with basic numeric inputs, you are responsible for managing the units properly. A solution is to provide units on inputs when calling methods to ensure all units are properly converted. Calls like this will return Unitful quantities. ","category":"page"},{"location":"units/","page":"Integration with Unitful.jl","title":"Integration with Unitful.jl","text":"@info \"Unitful arguments are converted to basic numeric types.\"\nd = GeneralIsothermal(1.0 * ua.Msun / ua.kpc^3, 1.0 * ua.pc, 2.5)\nrs = 1.0 # I might expect this to be in parsecs, like the scale radius I provided ...\nρ(d, rs) # But this assumes that rs is in the default length unit, which is kpc.\nrs = 1.0 * ua.pc # The safer way to do this is provide rs with units.\nρ(d, rs)","category":"page"},{"location":"docindex/#index","page":"Index","title":"Index","text":"","category":"section"},{"location":"docindex/","page":"Index","title":"Index","text":"Modules = [GalaxyProfiles]\nPages = [\"types.md\",\"methods.md\"]","category":"page"},{"location":"methods/#methods","page":"Defined Methods","title":"Defined Methods","text":"","category":"section"},{"location":"methods/#Common-Methods","page":"Defined Methods","title":"Common Methods","text":"","category":"section"},{"location":"methods/","page":"Defined Methods","title":"Defined Methods","text":"These common methods are defined for most density profiles, when possible.","category":"page"},{"location":"methods/#GalaxyProfiles.ρ-Tuple{GalaxyProfiles.AbstractDensity, Real}","page":"Defined Methods","title":"GalaxyProfiles.ρ","text":"ρ(d::AbstractDensity, r::Real)\nρ(uu::Unitful.DensityUnits, d::AbstractDensity, r::Real)\nρ(d::AbstractDensity, r::Unitful.Length)\nρ(uu::Unitful.DensityUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the density of profile d [M⊙ kpc^-3] at radius r [kpc].\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.invρ-Union{Tuple{V}, Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S, Tuple{V, V}}} where {T<:Real, S<:Real, V<:Real}","page":"Defined Methods","title":"GalaxyProfiles.invρ","text":"invρ(d::AbstractDensity, x::Real) # Only valid if specialized method exists\ninvρ(d::AbstractDensity, x::Real,\n     interval::NTuple{2,Real}=(scale_radius(d)/100,\n                               100*scale_radius(d)); kws...) # Root-finding generic method\ninvρ(uu::Unitful.LengthUnits, d::AbstractDensity, x::Real)\ninvρ(d::AbstractDensity, x::Unitful.Density)\ninvρ(uu::Unitful.LengthUnits, d::AbstractDensity, x::Unitful.Density)\n\nSolve for the radius r [kpc] at which the density [M⊙ kpc^-3] is x for density profile d. Requires x>0.\n\nWhen this method is not specialized for d, it will use an interval bracketing method from Roots.jl, requiring that ρ(d,r) be defined. For this method, kws... are passed to Roots.find_zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.∇ρ-Tuple{GalaxyProfiles.AbstractDensity, Real}","page":"Defined Methods","title":"GalaxyProfiles.∇ρ","text":"∇ρ(d::AbstractDensity, r::Real)\n∇ρ(uu::GalaxyProfiles.∇ρdimensionUnits, d::AbstractDensity, r::Real)\n∇ρ(d::AbstractDensity, r::Unitful.Length)\n∇ρ(uu::GalaxyProfiles.∇ρdimensionUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the radial derivative of the density [M⊙ kpc^-4] of the mass profile d evaluated at radius r [kpc].\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.ρmean-Tuple{GalaxyProfiles.AbstractDensity, Real}","page":"Defined Methods","title":"GalaxyProfiles.ρmean","text":"ρmean(d::AbstractDensity, r::Real)\nρmean(uu::Unitful.DensityUnits, d::AbstractDensity, r::Real)\nρmean(d::AbstractDensity, r::Unitful.Length)\nρmean(uu::Unitful.DensityUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the average density [M⊙ kpc^-3] of density profile d inside r [kpc]. The generic method uses enclosed mass divided by spherical volume; M(d,r) * 3 / (4π*r^3). \n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.invρmean-Union{Tuple{V}, Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S, Tuple{V, V}}} where {T<:Real, S<:Real, V<:Real}","page":"Defined Methods","title":"GalaxyProfiles.invρmean","text":"invρmean(d::AbstractDensity, x::Real)\ninvρmean(d::AbstractDensity, x::Real,\n         interval::NTuple{2,Real}=(scale_radius(d)/100,\n                                   100*scale_radius(d)); kws...)\ninvρmean(uu::Unitful.LengthUnits, d::AbstractDensity, x::Real)\ninvρmean(d::AbstractDensity, x::Unitful.Density)\ninvρmean(uu::Unitful.LengthUnits, d::AbstractDensity, x::Unitful.Density)\n\nSolve for the radius r [kpc] inside which the average density is x [M⊙ kpc^-3]. Requires x>0.\n\nWhen this method is not specialized for d, it will use an interval bracketing method from Roots.jl, requiring that ρmean(d,r) or M(d,r) be defined. For this method, kws... are passed to Roots.find_zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Σ-Tuple{GalaxyProfiles.AbstractMassProfile, Real}","page":"Defined Methods","title":"GalaxyProfiles.Σ","text":"Σ(d::AbstractMassProfile, r::Real)\nΣ(uu::GalaxyProfiles.SurfaceDensityUnits, d::AbstractMassProfile, r::Real)\nΣ(d::AbstractMassProfile, r::Unitful.Length)\nΣ(uu::GalaxyProfiles.SurfaceDensityUnits, d::AbstractMassProfile, r::Unitful.Length)\n\nReturns the surface density [M⊙ kpc^-2] of mass profile d at radius r. For 3D density profiles (i.e., subtypes of AbstractDensity), this will be the projected surface density, which, for spherical systems, is defined by the Abel integral \n\nSigma(r) = 2 int_R^infty rho(r) fracr sqrtr^2-R^2   dr\n\nwhich has an inverse of\n\nrho(r) = -frac1pi int_r^infty fracdSigma(R)dR fracdRsqrtR^2-r^2\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.invΣ-Union{Tuple{V}, Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractMassProfile{T}, S, Tuple{V, V}}} where {T<:Real, S<:Real, V<:Real}","page":"Defined Methods","title":"GalaxyProfiles.invΣ","text":"invΣ(d::AbstractMassProfile, x::Real)\ninvΣ(d::AbstractMassProfile, x::Real,\n     interval::NTuple{2,Real}=(scale_radius(d)/100,\n                               100*scale_radius(d)); kws...)\ninvΣ(uu::Unitful.LengthUnits, d::AbstractMassProfile, x::Real)\ninvΣ(d::AbstractMassProfile, r::Unitful.Length)\ninvΣ(uu::Unitful.LengthUnits, d::AbstractMassProfile, r::Unitful.Length)\n\nSolve for the radius r [kpc] at which the surface density [M⊙ kpc^-2] is x for profile d. Requires x>0.\n\nWhen this method is not specialized for d, it will use an interval bracketing method from Roots.jl, requiring that Σ(d,r) be defined. For this method, kws... are passed to Roots.find_zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.∇Σ-Tuple{GalaxyProfiles.AbstractMassProfile, Real}","page":"Defined Methods","title":"GalaxyProfiles.∇Σ","text":"∇Σ(d::AbstractMassProfile, r::Real)\n∇Σ(uu::Unitful.DensityUnits, d::AbstractMassProfile, r::Real)\n∇Σ(d::AbstractMassProfile, r::Unitful.Length)\n∇Σ(uu::Unitful.DensityUnits, d::AbstractMassProfile, r::Unitful.Length)\n\nReturns the radial derivative of the surface density [M⊙ kpc^-3] of the mass profile d evaluated at radius r [kpc].\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Σmean-Tuple{GalaxyProfiles.AbstractMassProfile, Real}","page":"Defined Methods","title":"GalaxyProfiles.Σmean","text":"Σmean(d::AbstractMassProfile, r::Real)\nΣmean(uu::GalaxyProfiles.SurfaceDensityUnits, d::AbstractMassProfile, r::Real)\nΣmean(d::AbstractMassProfile, r::Unitful.Length)\nΣmean(uu::GalaxyProfiles.SurfaceDensityUnits, d::AbstractMassProfile, r::Unitful.Length)\n\nReturns the mean projected surface density [M⊙ kpc^-2] of the mass profile d inside the radius r [kpc]. The generic method uses projected enclosed mass divided by area: Mproj(d::AbstractMassProfile,r::Real) / (π * r^2).\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.M-Tuple{GalaxyProfiles.AbstractDensity, Real}","page":"Defined Methods","title":"GalaxyProfiles.M","text":"M(d::AbstractDensity, r::Real)\nM(uu::Unitful.MassUnits, d::AbstractDensity, r::Real)\nM(d::AbstractDensity, r::Unitful.Length)\nM(uu::Unitful.MassUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the total mass [M⊙] of the profile d enclosed within a spherical shell of radius r. For spherical systems this is given by the integral\n\nM(lt R) = 4pi int_0^R r^2 ρ(r) dr\n\nWhen this method is not specialized for d, it will compute the numerical integral using QuadGK.quadgk.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.invM-Union{Tuple{V}, Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S, Tuple{V, V}}} where {T<:Real, S<:Real, V<:Real}","page":"Defined Methods","title":"GalaxyProfiles.invM","text":"invM(d::AbstractDensity, x::Real)\ninvM(d::AbstractDensity, x::Real,\n     interval::NTuple{2,Real}=(scale_radius(d)/100,\n                               100*scale_radius(d)); kws...)\ninvM(uu::Unitful.LengthUnits, d::AbstractDensity, x::Real)\ninvM(d::AbstractDensity, x::Unitful.Mass)\ninvM(uu::Unitful.LengthUnits, d::AbstractDensity, x::Unitful.Mass)\n\nSolve for the radius r [kpc] at which the enclosed mass [M⊙] is x for profile d. Requires x>0.\n\nWhen this method is not specialized for d, it will use an interval bracketing method from Roots.jl, requiring that M(d,r) be defined. For this method, kws... are passed to Roots.find_zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.∇M-Tuple{GalaxyProfiles.AbstractDensity, Real}","page":"Defined Methods","title":"GalaxyProfiles.∇M","text":"∇M(d::AbstractDensity, r::Real)\n∇M(uu::GalaxyProfiles.∇mdimensionUnits, d::AbstractDensity, r::Real)\n∇M(d::AbstractDensity, r::Unitful.Length)\n∇M(uu::GalaxyProfiles.∇mdimensionUnits, d::AbstractDensity, r::Unitful.Length)\n\nThe radial derivative of the enclosed mass [M⊙ kpc^-1] of profile d evaluated at radius r.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Mtot-Tuple{GalaxyProfiles.AbstractMassProfile}","page":"Defined Methods","title":"GalaxyProfiles.Mtot","text":"Mtot(d::AbstractMassProfile)\nMtot(uu::Unitful.MassUnits, d::AbstractMassProfile)\n\nReturns the total mass [kpc] of the profile d. For profiles which do not have a well-defined total mass M(d,Inf), this quantity should be defined as the limit lim_r to infty M(r).\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Mproj-Tuple{GalaxyProfiles.AbstractMassProfile, Real}","page":"Defined Methods","title":"GalaxyProfiles.Mproj","text":"Mproj(d::AbstractMassProfile, r::Real)\nMproj(uu::Unitful.MassUnits, d::AbstractMassProfile, r::Real)\nMproj(d::AbstractMassProfile, r::Unitful.Length)\nMproj(uu::Unitful.MassUnits, d::AbstractMassProfile, r::Unitful.Length)\n\nReturns the total line-of-sight projected mass [M⊙] enclosed within a radius r [kpc] for the profile d. For spherical systems this is given by the integral\n\nM_textproj(lt R) = 2pi int_0^R r  Sigma(r) dr = 2pi int_0^R r left( 2 int_r^infty rho(r^prime) fracr^prime sqrtr^prime  2-r^2   dr^prime right) dr\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.∇Mproj-Tuple{GalaxyProfiles.AbstractMassProfile, Real}","page":"Defined Methods","title":"GalaxyProfiles.∇Mproj","text":"∇Mproj(d::AbstractMassProfile, r::Real)\n∇Mproj(uu::GalaxyProfiles.∇mdimensionUnits, d::AbstractMassProfile, r::Real)\n∇Mproj(d::AbstractMassProfile, r::Unitful.Length)\n∇Mproj(uu::GalaxyProfiles.∇mdimensionUnits, d::AbstractMassProfile, r::Unitful.Length)\n\nThe radial derivative of the line-of-sight projected mass [M⊙ kpc^-1] of profile d enclosed within a radius r [kpc].\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.invMproj-Union{Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractMassProfile, T, Tuple{S, S}}} where {T<:Real, S<:Real}","page":"Defined Methods","title":"GalaxyProfiles.invMproj","text":"invMproj(d::AbstractMassProfile, x::Real)\ninvMproj(d::AbstractMassProfile, x::Real,\n         interval::NTuple{2,Real}=(scale_radius(d)/100,\n                                   100*scale_radius(d)); kws...)\ninvMproj(d::AbstractMassProfile, x::Unitful.Mass)\ninvMproj(uu::Unitful.LengthUnits, d::AbstractMassProfile, x::Unitful.Mass)\n\nSolve for the radius r [kpc] at which the line-of-sight projected enclosed mass is x [M⊙] for profile d. Requires x>0.\n\nWhen this method is not specialized for d, it will use an interval bracketing method from Roots.jl, requiring that M(d,r) be defined. For this method, kws... are passed to Roots.find_zero.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.dynamical_time-Union{Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S}} where {T<:Real, S<:Real}","page":"Defined Methods","title":"GalaxyProfiles.dynamical_time","text":"dynamical_time(d::Union{AbstractDensity, AbstractMassProfile}, r::Real)\ndynamical_time(d::Union{AbstractDensity, AbstractMassProfile}, r::Unitful.Length)\ndynamical_time(uu::Unitful.TimeUnits, d::Union{AbstractDensity, AbstractMassProfile}, r::Unitful.Length)\n\nReturns the dynamical time [yr] at radius r [kpc] in the provided density profile d. The dynamical time is a characteristic timescale associated with orbits in potentials. This implementation specifically calculates Equation 2.39 in Binney & Tremaine Galactic Dynamics 2E, with the replacement of the standard density ρ for the average density interior to r, ρmean, to better account for inhomogenous systems. \n\nt_textdyn left( r right) = sqrt frac3pi16  G  overlinerho left( r right) \n\nThe above equation is used when the argument d::AbstractDensity. As ρmean can be expressed as a function of the total mass interior to the orbit, this can also be written as\n\nbeginaligned\noverlinerho left( r right) = frac3  M left( r right)4  pi  r^3 newline\nt_textdyn left( r right) = pi  sqrt fracr^34  G  M left( r right) \nendaligned\n\nwhere M left( r right) is the mass enclosed inside radius r, provided by the method M. This equation is used when the argument d::AbstractMassProfile, with the substitution of the projected mass Mproj for the 3-D enclosed mass M, which is undefined for profiles that do not have ρ densities. \n\nAlternative Definitions\n\nNote that some authors prefer to omit the factor of sqrt frac116  = 14 in the denominator of the first equation above; this is, for example, the convention used by galpy. Dynamical times thus defined will be four times larger than those calculated by this method. \n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.cdf2D","page":"Defined Methods","title":"GalaxyProfiles.cdf2D","text":"cdf2D(d::AbstractMassProfile, r::Real)\ncdf2D(d::AbstractMassProfile, r::Unitful.Quantity)\n\nReturns the value of the cumulative distribution function of the mass profile d at r [kpc] in two dimensions (i.e., projected along a line of sight). This is defined as Mproj(d,r) / Mtot(d).\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.cdf3D","page":"Defined Methods","title":"GalaxyProfiles.cdf3D","text":"cdf3D(d::AbstractDensity, r::Real)\ncdf3D(d::AbstractDensity, r::Unitful.Quantity)\n\nReturns the value of the cumulative distribution function of the profile d at r [kpc] in three dimensions. This is defined as M(d,r) / Mtot(d).\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.ccdf2D","page":"Defined Methods","title":"GalaxyProfiles.ccdf2D","text":"ccdf2D(d::AbstractMassProfile, r::Real)\nccdf2D(d::AbstractMassProfile, r::Unitful.Quantity)\n\nReturns the value of the complementary cumulative distribution function of the profile d at r [kpc] in two dimensions (i.e., along a line of sight). This is defined as 1 - cdf2D(d,r) = 1 - Σ(d,r) / Mtot(d). \n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.ccdf3D","page":"Defined Methods","title":"GalaxyProfiles.ccdf3D","text":"ccdf3D(d::AbstractMassProfile, r::Real)\nccdf3D(d::AbstractMassProfile, r::Unitful.Quantity)\n\nReturns the value of the complementary cumulative distribution function of the profile d at r [kpc] in three dimensions. This is defined as 1 - cdf3D(d,r) = 1 - M(d,r) / Mtot(d). \n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.quantile2D","page":"Defined Methods","title":"GalaxyProfiles.quantile2D","text":"quantile2D(d::AbstractMassProfile, r::Real)\nquantile2D(d::AbstractMassProfile, r::Unitful.Quantity)\n\nReturns the value of the inverse cumulative distribution function of the profile d at r [kpc] in two dimensions (i.e., along a line of sight).\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.quantile3D","page":"Defined Methods","title":"GalaxyProfiles.quantile3D","text":"quantile3D(d::AbstractDensity, r::Real)\nquantile3D(d::AbstractDensity, r::Unitful.Quantity)\n\nReturns the value of the inverse cumulative distribution function of the profile d at r [kpc] in three dimensions.\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.cquantile2D","page":"Defined Methods","title":"GalaxyProfiles.cquantile2D","text":"cquantile2D(d::AbstractMassProfile, r::Real)\ncquantile2D(d::AbstractMassProfile, r::Unitful.Quantity)\n\nReturns the value of the complementary quantile of the profile d at r [kpc] in two dimensions (i.e., along a line of sight). This is defined as quantile2D(d, 1-r).\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.cquantile3D-Tuple{GalaxyProfiles.AbstractDensity, Real}","page":"Defined Methods","title":"GalaxyProfiles.cquantile3D","text":"cquantile3D(d::AbstractDensity, r::Real)\ncquantile3D(d::AbstractDensity, r::Unitful.Quantity)\n\nReturns the value of the complementary quantile of the profile d at r [kpc] in three dimensions. This is defined as quantile3D(d, 1-r).\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Vcirc-Union{Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S}} where {T<:Real, S<:Real}","page":"Defined Methods","title":"GalaxyProfiles.Vcirc","text":"Vcirc(d::AbstractDensity, r::Real)\nVcirc(uu::Unitful.VelocityUnits, d::AbstractDensity, r::Real)\nVcirc(d::AbstractDensity, r::Unitful.Length)\nVcirc(uu::Unitful.VelocityUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the circular velocity [km/s] at r [kpc], defined as the speed of a particle of insignificant mass in a circular orbit at radius r. This is calculated as\n\nv_c^2(r) = fracG M(r)r = r fracdPhidr = rnablaPhi(r)\n\nBy default uses G in units such that if rs and r are in kpc, the velocity ends up in km/s. For example, for GeneralIsothermal we have [G] = [kpc * km^2 / Msun / s^2] so that the velocity ends up in km/s. This method has a generic implementation of sqrt( GalaxyProfiles.constants.Gvelkpc * M(d::AbstractDensity,r) / r).\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Vesc-Tuple{GalaxyProfiles.AbstractDensity, Real}","page":"Defined Methods","title":"GalaxyProfiles.Vesc","text":"Vesc(d::AbstractDensity, r::Real)\nVesc(uu::Unitful.VelocityUnits, d::AbstractDensity, r::Real)\nVesc(d::AbstractDensity, r::Unitful.Length)\nVesc(uu::Unitful.VelocityUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the escape velocity [km/s] at r [kpc], calculated as\n\nv^2_textesc(r) = 2 Phi(r)\n\nif Phi to 0 for r to infty; see the note for Φ.\n\nBy default uses G in units such that if rs and r are in kpc, the velocity ends up in km/s. For example, for GeneralIsothermal we have [G] = [kpc * km^2 / Msun / s^2] so that the velocity ends up in km/s. \n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Vmax-Tuple{GalaxyProfiles.AbstractDensity}","page":"Defined Methods","title":"GalaxyProfiles.Vmax","text":"Vmax(d::AbstractDensity)\nVmax(uu::Unitful.VelocityUnits, d::AbstractDensity)\n\nReturns the maximum circular velocity [km/s] of d and the corresponding radius [kpc]. Can be found by solving\n\n    fracd v_c(r)dr = 0\n\nfor r, where v_c is the circular velocity, then evaluating the circular velocity at r.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.σr-Tuple{GalaxyProfiles.AbstractDensity, Real, Real}","page":"Defined Methods","title":"GalaxyProfiles.σr","text":"σr(d::AbstractDensity, r::Real, β::Real)\n\nReturns the radial velocity dispersion [km/s] of d at radius r [kpc] for constant velocity anisotropy β given by Equation 4.216 in Binney & Tremaine Galactic Dynamics 2E,\n\nsigma_r^2 left( R right) = frac1R^2beta  rho(R) int_R^infty r^2beta  rho(r)  fracdPhidr  dr\n\nand as fracdPhidr = -G M(r)  r^2 we can alternatively write\n\nsigma_r^2 left( R right) = fracGR^2beta  rho(R) int_R^infty r^2left( beta-1 right)  rho(r)  Mleft( r right)  dr\n\nwhich is the generic method as we expect M(r) to be more commonly available than fracdPhidr.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.σlos-Tuple{GalaxyProfiles.AbstractDensity, Real, Real}","page":"Defined Methods","title":"GalaxyProfiles.σlos","text":"σlos(d::AbstractDensity, r::Real, β::Real)\n\nReturns the line-of-sight projected velocity dispersion [km/s] of d at projected radius r [kpc] for constant velocity anisotropy β given by\n\nsigma_textLOS^2 left( R right) = frac2Sigma left( R right) int_R^infty left(1 - beta fracR^2r^2 right) fracr  rho left( r right)  sigma_r^2 left( r right)sqrtr^2 - R^2  dr\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.Φ-Union{Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S}} where {T<:Real, S<:Real}","page":"Defined Methods","title":"GalaxyProfiles.Φ","text":"Φ(d::AbstractDensity, r::Real)\nΦ(uu::GalaxyProfiles.ΦdimensionUnits, d::AbstractDensity, r::Real)\nΦ(d::AbstractDensity, r::Unitful.Length)\nΦ(uu::GalaxyProfiles.ΦdimensionUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the potential [km^2 s^-2] of the density distribution d at radius r [kpc].\n\nThis is typically defined as\n\nbeginaligned\nPhi(R) = -4pi G left( frac1R int_0^R r^2 rho(r) dr + int_R^infty r rho(r) dr right) newline\n= -G left( fracM (R)R - int_R^infty r rho(r) dr right) newline\n Phi(R) = -fracGR int_0^R dM(r) - G int_R^infty fracdM(r)r newline\nendaligned\n\nwhere M(R) is the mass internal to radius R. The final expression is used in the generic implementation of Φ. Given that there is also a generic implementation of M(R) that calculates it from the density ρ, the potential Φ can be calculated from a density profile by defining only the density ρ.\n\nIf an analytic expression for M(r) exists, then an equivalent equation expressed in terms of the enclosed mass may be used,\n\nbeginaligned\nPhi(R) = -4pi G left( frac1R int_0^R r^2 rho(r) dr + int_R^infty r rho(r) dr right) newline\n= -G left( fracM (R)R - int_R^infty fracdM(r)r right) newline\n= -G  int_R^infty fracM left( r right)r^2 dr newline\nendaligned\n\nThe above integrals are not finite for some mass distributions (e.g., GeneralIsothermal with some choices of α). In these cases, it is convention to define the potential ar r as the potential difference between r and the characteristic scale radius of the distribution; i.e.\n\nPhi(R) - Phi(R_s) = G int_R_s^R fracM(r)r^2 dr\n\nsuch that Phi(R_s)equiv0.\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.∇Φ-Union{Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S}} where {T<:Real, S<:Real}","page":"Defined Methods","title":"GalaxyProfiles.∇Φ","text":"∇Φ(d::AbstractDensity, r::Real)\n∇Φ(uu::u.AccelerationUnits, d::AbstractDensity, r::Real)\n∇Φ(d::AbstractDensity, r::Unitful.Length)\n∇Φ(uu::u.AccelerationUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the radial derivative of the potential Φ(d,r) [km s^-2] of profile d at radius r [kpc].\n\nFor a spherical mass distribution, the gravitational acceleration term in Newton's second law F=m*a is a = -G M(r)  r^2 = -nablaPhi by definition. This is derived from the definition of Φ below.\n\nDerivation from Φ\n\nRecall that the potential can be written as\n\nPhi(R) = -G  int_R^infty fracM left( r right)r^2 dr\n\nso that our derivative is\n\nbeginaligned\nnablaPhi(R) = fracpartial Phi (R)partial R newline\n= fracpartialpartial R left -G  int_R^infty fracM left( r right)r^2 dr right newline\nendaligned\n\nWe are thus taking a radial derivative of a radial integral. By applying the fundamental thereom of calculus and remembering that we desire lim_R to infty Phi(R) = 0, we can simply write\n\nbeginaligned\nnablaPhi(R) = fracG M left( r right)r^2\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"methods/#GalaxyProfiles.∇∇Φ-Union{Tuple{S}, Tuple{T}, Tuple{GalaxyProfiles.AbstractDensity{T}, S}} where {T<:Real, S<:Real}","page":"Defined Methods","title":"GalaxyProfiles.∇∇Φ","text":"∇∇Φ(d::AbstractDensity, r::Real)\n∇∇Φ(uu::GalaxyProfiles.∇∇ΦdimensionUnits, d::AbstractDensity, r::Real)\n∇∇Φ(d::AbstractDensity, r::Unitful.Length)\n∇∇Φ(uu::GalaxyProfiles.∇∇ΦdimensionUnits, d::AbstractDensity, r::Unitful.Length)\n\nReturns the second radial derivative of the potential Φ(d,r) [km s^-2 kpc^-1] evaluated at radius r [kpc].\n\nAs the first radial derivative nablaPhi(R) = fracG M left( r right)r^2, by the product rule the second radial derivative is\n\nnablanablaPhi(R) = G left( fracnabla M(R)r^2 - frac2 M(R)r^3 right)\n\nwhich is used as the generic implementation through the methods M and ∇M.\n\nNote that this is not the same as the Laplacian operator that appears the Poisson equation nabla^2 Phi(R) = 4 pi G rho(R). In spherical coordinates, the radial component of the left hand side of Poisson's equation expands to\n\nnabla^2 Phi(R) = frac1R^2 fracpartialpartial R left( R^2 fracpartial Phi(R)partial R right)\n\nwhich is not equivalent to the second radial gradient fracpartial^2 Phi(R)partial R^2, which is what this method returns.\n\n\n\n\n\n","category":"method"},{"location":"methods/#Private-Methods","page":"Defined Methods","title":"Private Methods","text":"","category":"section"},{"location":"methods/","page":"Defined Methods","title":"Defined Methods","text":"The following methods are defined for convenience or internal use but are not exported.","category":"page"},{"location":"methods/#GalaxyProfiles.plummer_a_to_rh","page":"Defined Methods","title":"GalaxyProfiles.plummer_a_to_rh","text":"plummer_a_to_rh(a::Real)\n\nReturns the 3-D half-light (or half-mass) radius given the Plummer scale radius a. This is equivalent to quantile3D(d::Plummer, 0.5) but faster because the argument x=0.5 is known at compile-time. Note that in projection (i.e., along a line-of-sight) the half-light radius is simply equal to the Plummer scale radius a, verifiable by quantile2D(d::Plummer, 0.5) == scale_radius(d).\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.plummer_angular_avalue","page":"Defined Methods","title":"GalaxyProfiles.plummer_angular_avalue","text":"plummer_angular_avalue(absmag, sb, DM)\n\nThis is an observational utility designed for use with the astronomical magnitude system. Returns the Plummer scale radius a given a desired absolute magnitude absmag, average surface brightness within the half-light radius sb, and distance modulus DM. If the units of sb are, for example, [mags/arcsec^2], and the units of absmag and DM should always be magnitudes, then this will return the Plummer scale radius a in [arcsec]. Mathematically, we solve the equation for the surface brightness S as a function of magnitude m = absmag + DM and area A=πr^2, with r being the half-light radius:\n\nbeginaligned\nS = m + 25 times log(A) = m + 25 times log(πr^2) = m + 25 times ( log(π) + 2log(r) ) newline\nr = textexp10 left(  fracS - m - 25  log(π)5 right) = textexp10 left(  fracS - m5 right) times π^12\nendaligned\n\nWe then only need to convert the half-light radius r to the scale radius a, which is just the inverse of GalaxyProfiles.plummer_a_to_rh.\n\nExamples\n\nFor a Plummer profile with a total magnitude of -5 (flux = -2.5*log10(mag) = 100), an average surface brightness within the half-light radius of 25 mag/arcsec^2, and a distance of 1 Mpc (DM = 5*log10(1e6 [pc] / 10 [pc]) = 25), we can compute the scale radius of the corresponding Plummer profile in arcseconds as \n\njulia> isapprox( GalaxyProfiles.plummer_angular_avalue(-5, 25, 25), 4.32; rtol=1e-2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"methods/#Random-Sampling","page":"Defined Methods","title":"Random Sampling","text":"","category":"section"},{"location":"methods/","page":"Defined Methods","title":"Defined Methods","text":"The following sampling methods for drawing positions from instantiated mass profiles are provided.","category":"page"},{"location":"methods/#GalaxyProfiles.sample2D_r!","page":"Defined Methods","title":"GalaxyProfiles.sample2D_r!","text":"sample2D_r!([rng::Random.AbstractRNG=Random.default_rng()], d::AbstractMassProfile, x::AbstractArray{<:Real})\n\nDraw multiple samples of the radius following the surface density profile of d and write them to x in place. By default, falls back to quantile2D.(d, rand!(rng, x)). See also sample2D_r.\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.sample2D_r","page":"Defined Methods","title":"GalaxyProfiles.sample2D_r","text":"sample2D_r([rng::Random.AbstractRNG=Random.default_rng()], d::AbstractMassProfile [, dims...])\n\nDraws samples of the radius following the surface density profile of d with shape [dims...], which can either be a Vararg{Int,N} (e.g., sample2D_r(rng, d, 2, 2) to generate a 2x2 Matrix) or a Dims{N}, which is an NTuple of N Ints (e.g., sample2D_r(rng, d, (2,2)). By default, falls back to quantile2D.(d, rand(rng [, dims...])). See also sample2D_r!.\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.sample3D_r!","page":"Defined Methods","title":"GalaxyProfiles.sample3D_r!","text":"sample3D_r!([rng::Random.AbstractRNG=Random.default_rng()], d::AbstractDensity, x::AbstractArray{<:Real})\n\nDraw multiple samples of the radius following the density profile of d and write them to x in place. By default, falls back to quantile3D.(d, rand!(rng, x)). See also sample3D_r.\n\n\n\n\n\n","category":"function"},{"location":"methods/#GalaxyProfiles.sample3D_r","page":"Defined Methods","title":"GalaxyProfiles.sample3D_r","text":"sample3D_r([rng::Random.AbstractRNG=Random.default_rng()], d::AbstractDensity [, dims...])\n\nSample random points following the density profile of d with shape [dims...], which can either be a Vararg{Int,N} (e.g., sample3D_r(rng, d, 2, 2) to generate a 2x2 Matrix) or a Dims{N}, which is an NTuple of N Ints (e.g., sample3D_r(rng, d, (2,2)). By default, falls back to quantile3D.(d, rand(rng [, dims...])). See also sample3D_r!.\n\n\n\n\n\n","category":"function"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Insert a brief description here with links to the other pages.","category":"page"},{"location":"types/#types","page":"Defined Types","title":"Defined Types","text":"","category":"section"},{"location":"types/#Abstract-Types","page":"Defined Types","title":"Abstract Types","text":"","category":"section"},{"location":"types/","page":"Defined Types","title":"Defined Types","text":"The highest level type defined in this package is the abstract type AbstractMassProfile, which all other profiles are subtyped from. Below these are AbstractDensity and AbstractSurfaceDensity; the latter is defined only as a surface density and will have no 3D quantities defined (e.g., ρ), while the former represents 3D density profiles.","category":"page"},{"location":"types/#GalaxyProfiles.AbstractMassProfile","page":"Defined Types","title":"GalaxyProfiles.AbstractMassProfile","text":"AbstractMassProfile{T <: Real}: abstract supertype for all mass profiles. \n\n\n\n\n\n","category":"type"},{"location":"types/#GalaxyProfiles.AbstractDensity","page":"Defined Types","title":"GalaxyProfiles.AbstractDensity","text":"AbstractDensity{T} <: AbstractMassProfile{T}: abstract supertype for all 3D density profiles. \n\n\n\n\n\n","category":"type"},{"location":"types/#GalaxyProfiles.AbstractSurfaceDensity","page":"Defined Types","title":"GalaxyProfiles.AbstractSurfaceDensity","text":"Abstract type (<:AbstractMassProfile) for surface density profiles for which 3D quantities are not defined. Radii for instances of AbstractSurfaceDensity are always 2D. \n\n\n\n\n\n","category":"type"},{"location":"types/#Densities","page":"Defined Types","title":"Densities","text":"","category":"section"},{"location":"types/","page":"Defined Types","title":"Defined Types","text":"The following concrete types, representing specific density profiles, are currently implemented:","category":"page"},{"location":"types/#GalaxyProfiles.CoreNFW","page":"Defined Types","title":"GalaxyProfiles.CoreNFW","text":"CoreNFW(ρ0::Real, rs::Real, rc::Real, n::Real)\n\nType implementing the CoreNFW density profile of Read et al. 2016. This is a modified NFW profile with lower central densities calibrated to reproduce the density profiles observed in their simulations. The parameters ρ0 and rs are identical to those for the NFW profile. However, the CoreNFW profile makes the following alteration to the enclosed mass,\n\nbeginaligned\nM_textcNFW(R) = M_textNFW(R) times f^n newline\nf^n = left texttanh left( fracrr_c right) right^n\nendaligned\n\nwhere the core radius r_c and n, which controls how shallow the core is (no core with n==0 and complete core with n==1), are new free parameters.\n\nSee also\n\nConstructor that uses galaxy properties, CoreNFWGalaxy.\n\n\n\n\n\n","category":"type"},{"location":"types/#GalaxyProfiles.GeneralIsothermal","page":"Defined Types","title":"GalaxyProfiles.GeneralIsothermal","text":"GeneralIsothermal(ρ0::Real, rs::Real, α::Real)\nGeneralIsothermal(ρ0::Unitful.Density, rs::Unitful.Length, α::Real)\nGeneralIsothermal(rs::Real, α::Real, M::Real, Rmax::Real)\nGeneralIsothermal(rs::Unitful.Length, α::Real, M::Unitful.Mass, Rmax::Unitful.Length)\n\nType describing general isothermal density profiles with scale radius rs, power-law index α, and density at rs of ρ0. The density profile is\n\nrho(r) = rho_0 times left( fracrR_s right)^-alpha\n\nThe fields of GeneralIsothermal are ρ0, rs, α. The default units of GeneralIsothermal are [ρ0] = [Msun/kpc^3], [r, rs] = [kpc], [M] = [Msun] when you construct GeneralIsothermal with Reals, like Float64. This is important for quantities like Vcirc, Vesc, Φ, ∇Φ, and ∇∇Φ which involve G; these will give incorrect results if the fields of GeneralIsothermal or the provided r are in different units. If you construct GeneralIsothermal with Unitful quantities, they will be internally converted. \n\nSince the total mass of the GeneralIsothermal profile is undefined when alpha geq 3, we define the the potential Φ to be 0 at rs for all instances of GeneralIsothermal.\n\nThe following methods are specialized on this type:\n\nρ, invρ, ∇ρ, Σ, ∇Σ, invΣ, M, ∇M, invM, Mproj, ∇Mproj, invMproj, Vcirc, Vesc, Φ, ∇Φ, ∇∇Φ\n\nSee also\n\nSIS\n\n\n\n\n\n","category":"type"},{"location":"types/#GalaxyProfiles.NFW","page":"Defined Types","title":"GalaxyProfiles.NFW","text":"NFW(ρ0::Real, rs::Real)\nNFW(ρ0::Unitful.Density, rs::Unitful.Length)\n\nType describing the Navarro-Frenk-White 1996 (NFW) density profile with scale radius rs and characteristic density ρ0. The density profile is\n\nrho(r) = fracrho_0(rR_s)  (1+rR_s)^2\n\nThe fields of NFW are ρ0, rs. The default units of NFW are [ρ0] = [Msun/kpc^3], [r, rs] = [kpc], [M] = [Msun]. This is important for quantities like Vcirc, Vesc, Φ, ∇Φ, and ∇∇Φ which involve the gravitational constant G; these will give incorrect results if the fields of NFW or the provided r are in different units.\n\nThe following public methods are defined on this type:\n\nρ, invρ, ∇ρ, ρmean, Σ, M, ∇M, invM, Mproj, ∇Mproj, Vmax, Vesc, Φ, ∇Φ, ∇∇Φ\n\n\n\n\n\n","category":"type"},{"location":"types/#GalaxyProfiles.Plummer","page":"Defined Types","title":"GalaxyProfiles.Plummer","text":"Plummer(M::Real, a::Real)\nPlummer(M::Unitful.Mass, a::Unitful.Length)\n\nType implementing the density profile first proposed by Plummer 1911 (see also Dejonghe 1987); this density profile is defined by the potential\n\nPhi(r) = -fracG  Msqrt r^2 + a^2  \n\nwhich corresponds to a density profile of\n\nrho(r) = frac3  M4 pi a^3  left( 1 + fracr^2a^2 right)^-52\n\nwhere M is the total mass of the system and a is the characteristic scale radius of the system. Following this, the fields of Plummer are M, a. This scale radius can be converted to the 3D half-light (or half-mass) radius via\n\nr_h = fracasqrt 05^-23 - 1 \n\nthe method GalaxyProfiles.plummer_a_to_rh is provided to perform this conversion. In projection (i.e., along a line-of-sight) the half-light radius is equal to the Plummer scale radius a, verifiable by quantile2D(d::Plummer, 0.5) == scale_radius(d). \n\nThe default units of Plummer are [M] = [Msun], [a, r] = [kpc]. This is important for quantities like Vcirc, Vesc, Φ, ∇Φ, and ∇∇Φ which involve the gravitational constant G; these will give incorrect results if the fields of Plummer or the provided r are in different units.\n\nThe following public methods are defined on this type:\n\nMtot, ρ, invρ, ∇ρ, ρmean, invρmean, Σ, ∇Σ, Σmean, invΣ, M, ∇M, invM, Mproj, ∇Mproj, invMproj, Vcirc, Vesc, Φ, ∇Φ, ∇∇Φ, cdf2D, cdf3D, ccdf2D, ccdf3D, quantile2D, quantile3D, cquantile2D, cquantile3D.\n\n\n\n\n\n","category":"type"},{"location":"types/#Surface-Densities","page":"Defined Types","title":"Surface Densities","text":"","category":"section"},{"location":"types/","page":"Defined Types","title":"Defined Types","text":"The following concrete types, representing specific surface density profiles, are currently implemented:","category":"page"},{"location":"types/#GalaxyProfiles.ExponentialDisk","page":"Defined Types","title":"GalaxyProfiles.ExponentialDisk","text":"ExponentialDisk(Σ0::Real,rs::Real)\nExponentialDisk(rs::Real;Σ0=nothing,M=nothing)\n\nType describing projected isotropic exponential surface density profiles with central surface density Σ0 and scale radius rs. The surface density profile is\n\nSigma(r) = rho_0 times exp left( frac-rR_s right)\n\nThe fields of ExponentialDisk are Σ0, rs. There are no methods defined for ExponentialDisk which use physical constants with units (e.g., G), so as long as ExponentialDisk.rs and the radius r you provide to methods are in the same units, and Σ0 is in units of [M/[r,rs]^2]everything will work out. Generally just want to make sure the length units are uniform.\n\nThe following public methods are defined on this type:\n\nΣ, ∇Σ, invΣ, Mproj, ∇Mproj, invMproj, Mtot, cdf2D, ccdf2D, quantile2D, cquantile2D\n\nSee also\n\nConvenience constructor ExponentialDiskDHI.\n\n\n\n\n\n","category":"type"},{"location":"types/#GalaxyProfiles.Sersic","page":"Defined Types","title":"GalaxyProfiles.Sersic","text":"Sersic(Σ0, r_e, n, q)\n\nType describing Sersic surface density profile, typically used to model the surface brightness profile of galaxies in images.\n\nArguments\n\nΣ0: surface density at radius r = r_e\nr_e: Sersic scale radius\nn: Sersic index controlling how steep/shallow the profile is\nq: minor-to-major axis ratio\n\nSigma(r) = Sigma_0 times exp left( -b_n left left(fracrr_e right)^1n - 1 right right)\n\nwhere b_n is derived from the Sersic index n (see equations 3, 4 of Graham & Driver 2005).\n\nThe fields of Sersic are Σ0, r_e, n, q. There are no methods defined for Sersic which use physical constants with units (e.g., G), so as long as Sersic.r_e and the radius r you provide to methods are in the same units, and Σ0 is in units of [M/[r,r_e]^2]everything will work out. Generally just want to make sure the length units are uniform.\n\nThe following public methods are defined on this type:\n\nΣ, ∇Σ, invΣ, Mproj, ∇Mproj, Mtot\n\n\n\n\n\n","category":"type"},{"location":"types/#Retrieving-Parameters","page":"Defined Types","title":"Retrieving Parameters","text":"","category":"section"},{"location":"types/","page":"Defined Types","title":"Defined Types","text":"The parameters that define these types can be retrieved with params and scale_radius","category":"page"},{"location":"types/#GalaxyProfiles.params-Tuple{GalaxyProfiles.AbstractMassProfile}","page":"Defined Types","title":"GalaxyProfiles.params","text":"params(d::AbstractMassProfile)\n\nGet the fields of the struct as expected by its defined methods.\n\n\n\n\n\n","category":"method"},{"location":"types/#GalaxyProfiles.scale_radius-Tuple{GalaxyProfiles.AbstractMassProfile}","page":"Defined Types","title":"GalaxyProfiles.scale_radius","text":"scale_radius(d::AbstractMassProfile)\nscale_radius(uu::Unitful.LengthUnits, d::AbstractMassProfile)\n\nReturns the characteristic scale radius of the profile; used for some default methods. An example is rs for the ExponentialDisk model. \n\n\n\n\n\n","category":"method"},{"location":"types/#Convenience-Constructors","page":"Defined Types","title":"Convenience Constructors","text":"","category":"section"},{"location":"types/","page":"Defined Types","title":"Defined Types","text":"We also provide some convenience constructors for other types such as the singular isothermal sphere, which returns an instance of GeneralIsothermal with α=2.","category":"page"},{"location":"types/#GalaxyProfiles.CoreNFWGalaxy","page":"Defined Types","title":"GalaxyProfiles.CoreNFWGalaxy","text":"CoreNFWGalaxy(ρ0::Real, rs::Real, t_sf::Real, rhalf::Real;\n              κ::Real=4//100, η::Real=175//100)\n\nAn alternative parameterization for the CoreNFW profile based on galaxy properties.\n\nThe standard CoreNFW type uses n and r_c to parameterize the Read et al. 2016 density model, but the authors relate these halo-level parameters to galaxy-level parameters in the following ways. They find n to be related to the total star formation time,\n\nbeginaligned\nn = texttanh left( q right) newline\nq = kappa  fract_textSFt_textdyn\nendaligned\n\nwhere t_textdyn is the circular orbit time at the NFW profile scale radius r_s. This is the orbital circumference divided by the speed; for profile p, this is 2π * p.rs / GalaxyProfiles.Vcirc(p, p.rs).\n\nThey also find the core radius r_c to be related to the projected stellar half-mass radius as\n\nr_c = eta  R_h\n\nThus if the total star formation time and projected stellar half-mass radius are known for a galaxy, one can calculate n and r_c given the alternative parameters eta and kappa. In their simulations, Read et al. find kappa=004 and eta=175, so these are the default values for this alternate parameterization.\n\n\n\n\n\n","category":"function"},{"location":"types/#GalaxyProfiles.SIS","page":"Defined Types","title":"GalaxyProfiles.SIS","text":"SIS(ρ0::Real, rs::Real)\nSIS(ρ0::Unitful.Density, rs::Unitful.Length)\nSIS(rs::Real, M::Real, Rmax::Real)\nSIS(rs::Unitful.Length, M::Unitful.Mass, Rmax::Unitful.Length)\n\nConvenience function to construct a singular isothermal sphere; i.e., a GeneralIsothermal with α=2.\n\n\n\n\n\n","category":"function"},{"location":"types/#GalaxyProfiles.ExponentialDiskDHI","page":"Defined Types","title":"GalaxyProfiles.ExponentialDiskDHI","text":"ExponentialDiskDHI(DHI::Real, MHI::Real, ΣDHI::Real=10^6)\nExponentialDiskDHI(DHI::Unitful.Length, MHI::Unitful.Mass,\n    ΣDHI::GalaxyProfiles.SurfaceDensity=1*UnitfulAstro.Msun/UnitfulAstro.pc^2)\n\nConvenience constructor for the ExponentialDisk surface density profile. This will take a diameter for the disk DHI (e.g., the diameter of a neutral hydrogen disk), its total mass MHI, and ΣDHI, the surface density at DHI, and return an ExponentialDisk object with the correct central density and scale radius.\n\nBy default, ΣDHI is 10^6 solar masses per square kiloparsec (equivalent to one solar mass per square parsec), such that you should provide DHI in kpc if you are using Real inputs.\n\nNotes\n\nAt high masses (e.g., 10^10  textM_odot  textM_textHI) the numerical inversion is impossible; in this case, the exponential disk scale radius is set to DHI/4. \n\n\n\n\n\n","category":"function"}]
}
